/*
 * Sonos-net ContentDirectoryService
 *
 * File is generated by [@svrooij/sonos-docs](https://github.com/svrooij/sonos-api-docs/tree/main/generator/sonos-docs)
 *
 * Repository https://github.com/svrooij/sonos-net
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

namespace Sonos.Base.Services;

using System.Threading;
using System.Threading.Tasks;

/// <summary>
/// ContentDirectoryService  - Browse for local content
/// </summary>
public partial class ContentDirectoryService : SonosBaseService<ContentDirectoryService.IContentDirectoryEvent>
{
    /// <summary>
    /// Create a new ContentDirectoryService
    /// </summary>
    /// <param name="options">Service options</param>
    public ContentDirectoryService(SonosServiceOptions options) : base(SonosService.ContentDirectory, "/MediaServer/ContentDirectory/Control", "/MediaServer/ContentDirectory/Event", options) { }


    /// <summary>
    /// Browse for content: Music library (A), share(S:), Sonos playlists(SQ:), Sonos favorites(FV:2), radio stations(R:0/0), radio shows(R:0/1), queue(Q:)). Recommendation: Send one request, check the `TotalMatches` and - if necessary - do additional requests with higher `StartingIndex`. In case of duplicates only the first is returned! Example: albums with same title, even if artists are different
    /// </summary>
    /// <param name="request"><see cref="BrowseRequest"/> payload</param>
    /// <param name="cancellationToken"><see cref="CancellationToken" /></param>
    /// <remarks>(1) If the title contains an apostrophe the returned uri will contain a `&apos;`. (2) Some libraries support a BrowseAndParse, so you don't have to parse the xml.</remarks>
    /// <returns>BrowseResponse</returns>
    public Task<BrowseResponse> BrowseAsync(BrowseRequest request, CancellationToken cancellationToken = default) => ExecuteRequestAsync<BrowseRequest, BrowseResponse>(request, cancellationToken, "Browse");

    /// <summary>
    /// CreateObject
    /// </summary>
    /// <param name="request"><see cref="CreateObjectRequest"/> payload</param>
    /// <param name="cancellationToken"><see cref="CancellationToken" /></param>
    /// <returns>CreateObjectResponse</returns>
    public Task<CreateObjectResponse> CreateObjectAsync(CreateObjectRequest request, CancellationToken cancellationToken = default) => ExecuteRequestAsync<CreateObjectRequest, CreateObjectResponse>(request, cancellationToken, "CreateObject");

    /// <summary>
    /// DestroyObject
    /// </summary>
    /// <param name="request"><see cref="DestroyObjectRequest"/> payload</param>
    /// <param name="cancellationToken"><see cref="CancellationToken" /></param>
    /// <returns>Success boolean</returns>
    public Task<bool> DestroyObjectAsync(DestroyObjectRequest request, CancellationToken cancellationToken = default) => ExecuteRequestAsync(request, cancellationToken, "DestroyObject");

    /// <summary>
    /// FindPrefix
    /// </summary>
    /// <param name="request"><see cref="FindPrefixRequest"/> payload</param>
    /// <param name="cancellationToken"><see cref="CancellationToken" /></param>
    /// <returns>FindPrefixResponse</returns>
    public Task<FindPrefixResponse> FindPrefixAsync(FindPrefixRequest request, CancellationToken cancellationToken = default) => ExecuteRequestAsync<FindPrefixRequest, FindPrefixResponse>(request, cancellationToken, "FindPrefix");

    /// <summary>
    /// Get the current album art display option such as `WMP`, `ITUNES` or `NONE`
    /// </summary>
    /// <param name="cancellationToken"><see cref="CancellationToken" /></param>
    /// <returns>GetAlbumArtistDisplayOptionResponse</returns>
    public Task<GetAlbumArtistDisplayOptionResponse> GetAlbumArtistDisplayOptionAsync(CancellationToken cancellationToken = default) => ExecuteRequestAsync<BaseRequest, GetAlbumArtistDisplayOptionResponse>(new BaseRequest(), cancellationToken, "GetAlbumArtistDisplayOption");

    /// <summary>
    /// GetAllPrefixLocations
    /// </summary>
    /// <param name="request"><see cref="GetAllPrefixLocationsRequest"/> payload</param>
    /// <param name="cancellationToken"><see cref="CancellationToken" /></param>
    /// <returns>GetAllPrefixLocationsResponse</returns>
    public Task<GetAllPrefixLocationsResponse> GetAllPrefixLocationsAsync(GetAllPrefixLocationsRequest request, CancellationToken cancellationToken = default) => ExecuteRequestAsync<GetAllPrefixLocationsRequest, GetAllPrefixLocationsResponse>(request, cancellationToken, "GetAllPrefixLocations");

    /// <summary>
    /// GetBrowseable
    /// </summary>
    /// <param name="cancellationToken"><see cref="CancellationToken" /></param>
    /// <returns>GetBrowseableResponse</returns>
    public Task<GetBrowseableResponse> GetBrowseableAsync(CancellationToken cancellationToken = default) => ExecuteRequestAsync<BaseRequest, GetBrowseableResponse>(new BaseRequest(), cancellationToken, "GetBrowseable");

    /// <summary>
    /// GetLastIndexChange
    /// </summary>
    /// <param name="cancellationToken"><see cref="CancellationToken" /></param>
    /// <returns>GetLastIndexChangeResponse</returns>
    public Task<GetLastIndexChangeResponse> GetLastIndexChangeAsync(CancellationToken cancellationToken = default) => ExecuteRequestAsync<BaseRequest, GetLastIndexChangeResponse>(new BaseRequest(), cancellationToken, "GetLastIndexChange");

    /// <summary>
    /// GetSearchCapabilities
    /// </summary>
    /// <param name="cancellationToken"><see cref="CancellationToken" /></param>
    /// <returns>GetSearchCapabilitiesResponse</returns>
    public Task<GetSearchCapabilitiesResponse> GetSearchCapabilitiesAsync(CancellationToken cancellationToken = default) => ExecuteRequestAsync<BaseRequest, GetSearchCapabilitiesResponse>(new BaseRequest(), cancellationToken, "GetSearchCapabilities");

    /// <summary>
    /// GetShareIndexInProgress
    /// </summary>
    /// <param name="cancellationToken"><see cref="CancellationToken" /></param>
    /// <returns>GetShareIndexInProgressResponse</returns>
    public Task<GetShareIndexInProgressResponse> GetShareIndexInProgressAsync(CancellationToken cancellationToken = default) => ExecuteRequestAsync<BaseRequest, GetShareIndexInProgressResponse>(new BaseRequest(), cancellationToken, "GetShareIndexInProgress");

    /// <summary>
    /// GetSortCapabilities
    /// </summary>
    /// <param name="cancellationToken"><see cref="CancellationToken" /></param>
    /// <returns>GetSortCapabilitiesResponse</returns>
    public Task<GetSortCapabilitiesResponse> GetSortCapabilitiesAsync(CancellationToken cancellationToken = default) => ExecuteRequestAsync<BaseRequest, GetSortCapabilitiesResponse>(new BaseRequest(), cancellationToken, "GetSortCapabilities");

    /// <summary>
    /// GetSystemUpdateID
    /// </summary>
    /// <param name="cancellationToken"><see cref="CancellationToken" /></param>
    /// <returns>GetSystemUpdateIDResponse</returns>
    public Task<GetSystemUpdateIDResponse> GetSystemUpdateIDAsync(CancellationToken cancellationToken = default) => ExecuteRequestAsync<BaseRequest, GetSystemUpdateIDResponse>(new BaseRequest(), cancellationToken, "GetSystemUpdateID");

    /// <summary>
    /// Updates the music library (share) index
    /// </summary>
    /// <param name="request"><see cref="RefreshShareIndexRequest"/> payload</param>
    /// <param name="cancellationToken"><see cref="CancellationToken" /></param>
    /// <returns>Success boolean</returns>
    public Task<bool> RefreshShareIndexAsync(RefreshShareIndexRequest request, CancellationToken cancellationToken = default) => ExecuteRequestAsync(request, cancellationToken, "RefreshShareIndex");

    /// <summary>
    /// RequestResort
    /// </summary>
    /// <param name="request"><see cref="RequestResortRequest"/> payload</param>
    /// <param name="cancellationToken"><see cref="CancellationToken" /></param>
    /// <returns>Success boolean</returns>
    public Task<bool> RequestResortAsync(RequestResortRequest request, CancellationToken cancellationToken = default) => ExecuteRequestAsync(request, cancellationToken, "RequestResort");

    /// <summary>
    /// SetBrowseable
    /// </summary>
    /// <param name="request"><see cref="SetBrowseableRequest"/> payload</param>
    /// <param name="cancellationToken"><see cref="CancellationToken" /></param>
    /// <returns>Success boolean</returns>
    public Task<bool> SetBrowseableAsync(SetBrowseableRequest request, CancellationToken cancellationToken = default) => ExecuteRequestAsync(request, cancellationToken, "SetBrowseable");

    /// <summary>
    /// UpdateObject
    /// </summary>
    /// <param name="request"><see cref="UpdateObjectRequest"/> payload</param>
    /// <param name="cancellationToken"><see cref="CancellationToken" /></param>
    /// <returns>Success boolean</returns>
    public Task<bool> UpdateObjectAsync(UpdateObjectRequest request, CancellationToken cancellationToken = default) => ExecuteRequestAsync(request, cancellationToken, "UpdateObject");

    [System.Xml.Serialization.XmlRoot(Namespace = "")]
    [SonosServiceRequest("/MediaServer/ContentDirectory/Control", "ContentDirectory")]
    public class BaseRequest
    {
        [System.Xml.Serialization.XmlNamespaceDeclarations]
        public System.Xml.Serialization.XmlSerializerNamespaces xmlns = new System.Xml.Serialization.XmlSerializerNamespaces(
          new[] { new System.Xml.XmlQualifiedName("u", "urn:schemas-upnp-org:service:ContentDirectory:1"), });
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlRoot(Namespace = "")]
    [SonosServiceRequest("/MediaServer/ContentDirectory/Control", "ContentDirectory", "Browse")]
    public class BrowseRequest : BaseRequest
    {
        /// <summary>
        /// The search query, (`A:ARTIST` / `A:ALBUMARTIST` / `A:ALBUM` / `A:GENRE` / `A:COMPOSER` / `A:TRACKS` / `A:PLAYLISTS` / `FV:2` / `Q:`/ `R:0/0` / `R:0/1` / `S:` / `SQ:`) with optionally `:search+query` behind it.
        /// </summary>
        public string ObjectID { get; set; }

        /// <summary>
        /// How to browse
        /// </summary>
        public string BrowseFlag { get; set; }

        /// <summary>
        /// Which fields should be returned `*` for all.
        /// </summary>
        public string Filter { get; set; }

        /// <summary>
        /// Paging, where to start, usually 0
        /// </summary>
        public int StartingIndex { get; set; }

        /// <summary>
        /// Paging, number of items, maximum is 1,000. This parameter does NOT restrict the number of items being searched (filter) but only the number being returned. Using 0 is equivalent to 1,000
        /// </summary>
        public int RequestedCount { get; set; }

        /// <summary>
        /// Sort the results based on metadata fields. `+upnp:artist,+dc:title` for sorting on artist then on title.
        /// </summary>
        public string SortCriteria { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlType("BrowseResponse", AnonymousType = true, Namespace = "urn:schemas-upnp-org:service:ContentDirectory:1")]
    public partial class BrowseResponse
    {
        /// <summary>
        /// Encoded DIDL-Lite XML. See remark (2)
        /// </summary>
        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public string Result { get; set; }

        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public int NumberReturned { get; set; }

        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public int TotalMatches { get; set; }

        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public int UpdateID { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlRoot(Namespace = "")]
    [SonosServiceRequest("/MediaServer/ContentDirectory/Control", "ContentDirectory", "CreateObject")]
    public class CreateObjectRequest : BaseRequest
    {
        public string ContainerID { get; set; }

        public string Elements { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlType("CreateObjectResponse", AnonymousType = true, Namespace = "urn:schemas-upnp-org:service:ContentDirectory:1")]
    public partial class CreateObjectResponse
    {
        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public string ObjectID { get; set; }

        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public string Result { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlRoot(Namespace = "")]
    [SonosServiceRequest("/MediaServer/ContentDirectory/Control", "ContentDirectory", "DestroyObject")]
    public class DestroyObjectRequest : BaseRequest
    {
        public string ObjectID { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlRoot(Namespace = "")]
    [SonosServiceRequest("/MediaServer/ContentDirectory/Control", "ContentDirectory", "FindPrefix")]
    public class FindPrefixRequest : BaseRequest
    {
        public string ObjectID { get; set; }

        public string Prefix { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlType("FindPrefixResponse", AnonymousType = true, Namespace = "urn:schemas-upnp-org:service:ContentDirectory:1")]
    public partial class FindPrefixResponse
    {
        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public int StartingIndex { get; set; }

        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public int UpdateID { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlType("GetAlbumArtistDisplayOptionResponse", AnonymousType = true, Namespace = "urn:schemas-upnp-org:service:ContentDirectory:1")]
    public partial class GetAlbumArtistDisplayOptionResponse
    {
        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public string AlbumArtistDisplayOption { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlRoot(Namespace = "")]
    [SonosServiceRequest("/MediaServer/ContentDirectory/Control", "ContentDirectory", "GetAllPrefixLocations")]
    public class GetAllPrefixLocationsRequest : BaseRequest
    {
        public string ObjectID { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlType("GetAllPrefixLocationsResponse", AnonymousType = true, Namespace = "urn:schemas-upnp-org:service:ContentDirectory:1")]
    public partial class GetAllPrefixLocationsResponse
    {
        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public int TotalPrefixes { get; set; }

        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public string PrefixAndIndexCSV { get; set; }

        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public int UpdateID { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlType("GetBrowseableResponse", AnonymousType = true, Namespace = "urn:schemas-upnp-org:service:ContentDirectory:1")]
    public partial class GetBrowseableResponse
    {
        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public bool IsBrowseable { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlType("GetLastIndexChangeResponse", AnonymousType = true, Namespace = "urn:schemas-upnp-org:service:ContentDirectory:1")]
    public partial class GetLastIndexChangeResponse
    {
        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public string LastIndexChange { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlType("GetSearchCapabilitiesResponse", AnonymousType = true, Namespace = "urn:schemas-upnp-org:service:ContentDirectory:1")]
    public partial class GetSearchCapabilitiesResponse
    {
        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public string SearchCaps { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlType("GetShareIndexInProgressResponse", AnonymousType = true, Namespace = "urn:schemas-upnp-org:service:ContentDirectory:1")]
    public partial class GetShareIndexInProgressResponse
    {
        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public bool IsIndexing { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlType("GetSortCapabilitiesResponse", AnonymousType = true, Namespace = "urn:schemas-upnp-org:service:ContentDirectory:1")]
    public partial class GetSortCapabilitiesResponse
    {
        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public string SortCaps { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlType("GetSystemUpdateIDResponse", AnonymousType = true, Namespace = "urn:schemas-upnp-org:service:ContentDirectory:1")]
    public partial class GetSystemUpdateIDResponse
    {
        [System.Xml.Serialization.XmlElement(Namespace = "")]
        public int Id { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlRoot(Namespace = "")]
    [SonosServiceRequest("/MediaServer/ContentDirectory/Control", "ContentDirectory", "RefreshShareIndex")]
    public class RefreshShareIndexRequest : BaseRequest
    {
        /// <summary>
        /// `WMP`, `ITUNES` or `NONE`
        /// </summary>
        public string AlbumArtistDisplayOption { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlRoot(Namespace = "")]
    [SonosServiceRequest("/MediaServer/ContentDirectory/Control", "ContentDirectory", "RequestResort")]
    public class RequestResortRequest : BaseRequest
    {
        public string SortOrder { get; set; }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlRoot(Namespace = "")]
    [SonosServiceRequest("/MediaServer/ContentDirectory/Control", "ContentDirectory", "SetBrowseable")]
    public class SetBrowseableRequest : BaseRequest
    {
        [System.Xml.Serialization.XmlIgnore]
        public bool Browseable { get; set; }

        /// <remarks>Noting to see here, XmlSerializer issue, use 'Browseable'</remarks>
        [System.Xml.Serialization.XmlElement("Browseable")]
        public int _Browseable { get { return Browseable ? 1 : 0; } set { Browseable = value == 1; } }
    }

    [System.Serializable()]
    [System.Xml.Serialization.XmlRoot(Namespace = "")]
    [SonosServiceRequest("/MediaServer/ContentDirectory/Control", "ContentDirectory", "UpdateObject")]
    public class UpdateObjectRequest : BaseRequest
    {
        public string ObjectID { get; set; }

        public string CurrentTagValue { get; set; }

        public string NewTagValue { get; set; }
    }

    private readonly static Dictionary<int, SonosUpnpError> serviceSpecificErrors = new Dictionary<int, SonosUpnpError>{
        { 701, new SonosUpnpError(701, "No such object") },
        { 702, new SonosUpnpError(702, "Invalid CurrentTagValue") },
        { 703, new SonosUpnpError(703, "Invalid NewTagValue") },
        { 704, new SonosUpnpError(704, "Required tag") },
        { 705, new SonosUpnpError(705, "Read-only tag") },
        { 706, new SonosUpnpError(706, "Parameter mismatch") },
        { 708, new SonosUpnpError(708, "Invalid search criteria") },
        { 709, new SonosUpnpError(709, "Invalid sort criteria") },
        { 710, new SonosUpnpError(710, "No such container") },
        { 711, new SonosUpnpError(711, "Restricted object") },
        { 712, new SonosUpnpError(712, "Bad metadata") },
        { 713, new SonosUpnpError(713, "Restricted parent object") },
        { 714, new SonosUpnpError(714, "No such source resource") },
        { 715, new SonosUpnpError(715, "Resource access denied") },
        { 716, new SonosUpnpError(716, "Transfer busy") },
        { 717, new SonosUpnpError(717, "No such file transfer") },
        { 718, new SonosUpnpError(718, "No such destination resource") },
        { 719, new SonosUpnpError(719, "Destination resource access denied") },
        { 720, new SonosUpnpError(720, "Cannot process the request") },
    };

    internal override Dictionary<int, SonosUpnpError> ServiceErrors => serviceSpecificErrors.Merge(base.ServiceErrors);

    /// <summary>
    /// ContentDirectory is set to might emit these properties in events
    /// </summary>
    public partial interface IContentDirectoryEvent : IServiceEvent
    {
        public bool? Browseable { get; }

        public string? ContainerUpdateIDs { get; }

        public string? FavoritePresetsUpdateID { get; }

        public string? FavoritesUpdateID { get; }

        public int? RadioFavoritesUpdateID { get; }

        public int? RadioLocationUpdateID { get; }

        public string? RecentlyPlayedUpdateID { get; }

        public string? SavedQueuesUpdateID { get; }

        public string? SearchCapabilities { get; }

        public bool? ShareIndexInProgress { get; }

        public string? ShareIndexLastError { get; }

        public string? ShareListUpdateID { get; }

        public string? SortCapabilities { get; }

        public int? SystemUpdateID { get; }

        public string? UserRadioUpdateID { get; }
    }

    /// <summary>
    /// Browse for content: Music library (A), share(S:), Sonos playlists(SQ:), Sonos favorites(FV:2), radio stations(R:0/0), radio shows(R:0/1), queue(Q:)). Recommendation: Send one request, check the `TotalMatches` and - if necessary - do additional requests with higher `StartingIndex`. In case of duplicates only the first is returned! Example: albums with same title, even if artists are different
    /// </summary>
    /// <param name="request">Body payload</param>
    /// <param name="cancellationToken">CancellationToken</param>
    /// <remarks>(1) If the title contains an apostrophe the returned uri will contain a `&apos;`. (2) Some libraries support a BrowseAndParse, so you don't have to parse the xml.</remarks>
    /// <returns>BrowseResponse</returns>
    [Obsolete("This method is obsolete. Use BrowseAsync instead.")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public Task<BrowseResponse> Browse(BrowseRequest request, CancellationToken cancellationToken = default) => BrowseAsync(request, cancellationToken);

    /// <summary>
    /// CreateObject
    /// </summary>
    /// <param name="request">Body payload</param>
    /// <param name="cancellationToken">CancellationToken</param>
    /// <returns>CreateObjectResponse</returns>
    [Obsolete("This method is obsolete. Use CreateObjectAsync instead.")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public Task<CreateObjectResponse> CreateObject(CreateObjectRequest request, CancellationToken cancellationToken = default) => CreateObjectAsync(request, cancellationToken);

    /// <summary>
    /// DestroyObject
    /// </summary>
    /// <param name="request">Body payload</param>
    /// <param name="cancellationToken">CancellationToken</param>
    /// <returns>Success boolean</returns>
    [Obsolete("This method is obsolete. Use DestroyObjectAsync instead.")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public Task<bool> DestroyObject(DestroyObjectRequest request, CancellationToken cancellationToken = default) => DestroyObjectAsync(request, cancellationToken);

    /// <summary>
    /// FindPrefix
    /// </summary>
    /// <param name="request">Body payload</param>
    /// <param name="cancellationToken">CancellationToken</param>
    /// <returns>FindPrefixResponse</returns>
    [Obsolete("This method is obsolete. Use FindPrefixAsync instead.")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public Task<FindPrefixResponse> FindPrefix(FindPrefixRequest request, CancellationToken cancellationToken = default) => FindPrefixAsync(request, cancellationToken);

    /// <summary>
    /// Get the current album art display option such as `WMP`, `ITUNES` or `NONE`
    /// </summary>
    /// <param name="cancellationToken">CancellationToken</param>
    /// <returns>GetAlbumArtistDisplayOptionResponse</returns>
    [Obsolete("This method is obsolete. Use GetAlbumArtistDisplayOptionAsync instead.")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public Task<GetAlbumArtistDisplayOptionResponse> GetAlbumArtistDisplayOption(CancellationToken cancellationToken = default) => GetAlbumArtistDisplayOptionAsync(cancellationToken);

    /// <summary>
    /// GetAllPrefixLocations
    /// </summary>
    /// <param name="request">Body payload</param>
    /// <param name="cancellationToken">CancellationToken</param>
    /// <returns>GetAllPrefixLocationsResponse</returns>
    [Obsolete("This method is obsolete. Use GetAllPrefixLocationsAsync instead.")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public Task<GetAllPrefixLocationsResponse> GetAllPrefixLocations(GetAllPrefixLocationsRequest request, CancellationToken cancellationToken = default) => GetAllPrefixLocationsAsync(request, cancellationToken);

    /// <summary>
    /// GetBrowseable
    /// </summary>
    /// <param name="cancellationToken">CancellationToken</param>
    /// <returns>GetBrowseableResponse</returns>
    [Obsolete("This method is obsolete. Use GetBrowseableAsync instead.")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public Task<GetBrowseableResponse> GetBrowseable(CancellationToken cancellationToken = default) => GetBrowseableAsync(cancellationToken);

    /// <summary>
    /// GetLastIndexChange
    /// </summary>
    /// <param name="cancellationToken">CancellationToken</param>
    /// <returns>GetLastIndexChangeResponse</returns>
    [Obsolete("This method is obsolete. Use GetLastIndexChangeAsync instead.")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public Task<GetLastIndexChangeResponse> GetLastIndexChange(CancellationToken cancellationToken = default) => GetLastIndexChangeAsync(cancellationToken);

    /// <summary>
    /// GetSearchCapabilities
    /// </summary>
    /// <param name="cancellationToken">CancellationToken</param>
    /// <returns>GetSearchCapabilitiesResponse</returns>
    [Obsolete("This method is obsolete. Use GetSearchCapabilitiesAsync instead.")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public Task<GetSearchCapabilitiesResponse> GetSearchCapabilities(CancellationToken cancellationToken = default) => GetSearchCapabilitiesAsync(cancellationToken);

    /// <summary>
    /// GetShareIndexInProgress
    /// </summary>
    /// <param name="cancellationToken">CancellationToken</param>
    /// <returns>GetShareIndexInProgressResponse</returns>
    [Obsolete("This method is obsolete. Use GetShareIndexInProgressAsync instead.")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public Task<GetShareIndexInProgressResponse> GetShareIndexInProgress(CancellationToken cancellationToken = default) => GetShareIndexInProgressAsync(cancellationToken);

    /// <summary>
    /// GetSortCapabilities
    /// </summary>
    /// <param name="cancellationToken">CancellationToken</param>
    /// <returns>GetSortCapabilitiesResponse</returns>
    [Obsolete("This method is obsolete. Use GetSortCapabilitiesAsync instead.")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public Task<GetSortCapabilitiesResponse> GetSortCapabilities(CancellationToken cancellationToken = default) => GetSortCapabilitiesAsync(cancellationToken);

    /// <summary>
    /// GetSystemUpdateID
    /// </summary>
    /// <param name="cancellationToken">CancellationToken</param>
    /// <returns>GetSystemUpdateIDResponse</returns>
    [Obsolete("This method is obsolete. Use GetSystemUpdateIDAsync instead.")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public Task<GetSystemUpdateIDResponse> GetSystemUpdateID(CancellationToken cancellationToken = default) => GetSystemUpdateIDAsync(cancellationToken);

    /// <summary>
    /// Updates the music library (share) index
    /// </summary>
    /// <param name="request">Body payload</param>
    /// <param name="cancellationToken">CancellationToken</param>
    /// <returns>Success boolean</returns>
    [Obsolete("This method is obsolete. Use RefreshShareIndexAsync instead.")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public Task<bool> RefreshShareIndex(RefreshShareIndexRequest request, CancellationToken cancellationToken = default) => RefreshShareIndexAsync(request, cancellationToken);

    /// <summary>
    /// RequestResort
    /// </summary>
    /// <param name="request">Body payload</param>
    /// <param name="cancellationToken">CancellationToken</param>
    /// <returns>Success boolean</returns>
    [Obsolete("This method is obsolete. Use RequestResortAsync instead.")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public Task<bool> RequestResort(RequestResortRequest request, CancellationToken cancellationToken = default) => RequestResortAsync(request, cancellationToken);

    /// <summary>
    /// SetBrowseable
    /// </summary>
    /// <param name="request">Body payload</param>
    /// <param name="cancellationToken">CancellationToken</param>
    /// <returns>Success boolean</returns>
    [Obsolete("This method is obsolete. Use SetBrowseableAsync instead.")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public Task<bool> SetBrowseable(SetBrowseableRequest request, CancellationToken cancellationToken = default) => SetBrowseableAsync(request, cancellationToken);

    /// <summary>
    /// UpdateObject
    /// </summary>
    /// <param name="request">Body payload</param>
    /// <param name="cancellationToken">CancellationToken</param>
    /// <returns>Success boolean</returns>
    [Obsolete("This method is obsolete. Use UpdateObjectAsync instead.")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public Task<bool> UpdateObject(UpdateObjectRequest request, CancellationToken cancellationToken = default) => UpdateObjectAsync(request, cancellationToken);
}
